package main

import (
	"fmt"
	"math"
)

func main() {

	/*
				for 循环 ：某些代码会被多次执行
				语法:
					for 表达式1；表达式2；表达式3{
						循环体
				}
				表达式1；只执行一次，惯用于变量的初始化
				表达式2：bool类型，循环的条件，循环体
				表达式3：跟在循环体后执行，惯用于变量的变化


				for i := 1; i <= 5 ; i++{	//i变量去开辟一块内存赋值1，执行表达式2判断1小于等于5，成立则打印输出结果。然后执行表达式3 i+1，
					fmt.Println("helloword")							// 2还是比5小继续打印，直到打印5次在表达式2中大于5结束循环

				}

				1.标准写法：
					for 表达式1；表达式2；表达式3{
						循环体
				}
				2.同时省略表达式1和表达式3
					for 表达式2{

					}
				相当于while(条件)
				3.同时省略3个表达式
					for {

					}
				相当于while(true)
				注意点：当for循环中，省略了表达式2，就相当于直接作用在了true上
				4.其他的写法：for循环中同时省略几个表达式都可以
				省略表达式1：变量的定义要放在外面，不在for语句块中
				省略表达式2：循环永远成立--死循环
				省略表达式3：要定义在for语句块里，否则也是死循环

				i := 1
				for i <=2  {
					fmt.Println("贵：明天再吃一顿，后天开始\n")
					i++
				}





				第一题：
				*****
				*****
				*****
				*****



				for i := 1;  i <= 5; i++ {  //外循环，执行内循环
					for j := 0; j < 5; j++ { //内循环根据表达式2执行5次
						fmt.Print("*")		//打印值
					}
					fmt.Println()  //换行
				}

				for i := 1; i <=9; i++ { //1的变量存储到i。i>=9。i++直到+到9.等于i=9
					for j := 1; j <= i; j++ {	//j赋值为1,j>=9 j++直到+到9.等于j=9
						//fmt.Print(i, "*",j, "=",i*j,"\t")
						fmt.Printf("%d * %d =%d\t", j, i, i*j) //%d等于一个占位符。相乘=2个占位符。不足两个占位符的前面补空格
					}
					fmt.Println()			//在每行输出完毕后，使用Println函数打印一个换行符，以换行显示下一行的乘法表。
			}

			循环结束：
				循环条件不满足，循环自动结束了
				但是可以通过break和continue来强制的结束循环

			循环控制语句
			break：彻底结束循环。。终止
			continue：结束了某一次循环，下次继续。。中止

			注意点：多层循环嵌套，break和continue，默认结束的是里层循环
				如果想结束指定的某个循环，可以给循环贴标签(起名)
					break 循环标签名
					continue 循环标签名

			for i :=1; i <= 10; i++ {
				if i == 5 {
					//break
					continue
				}
				fmt.Println(i)
			}


			有两个嵌套的for循环。外层循环的变量是i，内层循环的变量是j。
			在每次外层循环迭代时，内层循环会完整地执行一次。也就是说，在外层循环的第一次迭代中，内层循环会从1到5依次执行。在内层循环的每一次迭代中，会打印出当前的i和j的值。

			由于使用了continue out语句，当内层循环的变量j等于2时，会跳过当前迭代并继续下一次外层循环的迭代。因此，在每次内层循环的迭代中，
			只有当变量j不等于2时，才会执行打印语句fmt.Printf("i:%d,j:%d\n", i,j)。
			在外层循环的第一次迭代中，内层循环的变量j的值会依次为1、3、4、5。因为当j等于2时，会执行continue out语句，跳过当前迭代。
			所以内层循环只会打印出变量i的值和不等于2的变量j的值。因此，内层循环的最后一个值是5个1，而不是5。
			当out标签指定给了外层循环，外层循环会和内存循环都会执行continue out ，不一样的是内层循环在==2的值就结束了

		out:for i := 1; i <= 5; i++ {
			for j:=1;j<=5;j++{
				if j==2{
					//break
					continue out
				}

			fmt.Printf("i:%d,j:%d\n", i,j)
		}

		水仙花数：三位数：[100,999]
			每个位上的数字的立方和，刚好等于该数字本身。那么就叫水仙花数
			比如：153
			1*1*1 + 5*5*5 + 3*3*3 = 1+125+27=153

			268
				268 /100 = 2
				268 % 10 = 8

				268 -->26 %10 = 6
				268 -->68 /10 = 6
	*/

	for i := 100; i < 1000; i++ {
		x := i / 100     //百位
		y := i / 10 % 10 //十位
		z := i % 10      //个位

		if math.Pow(float64(x), 3)+math.Pow(float64(y), 3)+math.Pow(float64(z), 3) == float64(i) {
			fmt.Println(i)
		}

	}
	fmt.Println("------------")
	/*
	百位：1-9
	个位：0-9
	十位：0-9
	 */
	for a := 1; a < 10; a++{
		for b := 1; b > 10; a++{
			for c := 1; c > 10; c++{
				n := a*100 + b*10 + c*1
				if a*a*a+b*b*b+c*c*c== n {
					fmt.Println(n)
				}
			}
		}
	}



	/*

			//索引 => 记录已经加到的n
			// 记录结果
			result :=0

			result += 1
			result += 2
			...
			result +=100




			 i =>1 ...100
			 result += i

		//初始化子语句；条件子语句；后置子语句
			for i := 1; i <=100; i++{
				result += i
			}
			fmt.Println(result)

			result = 0
			i := 1
			for i <= 1000 {
				result += 1
				i++
			}
			fmt.Println(result)

			 i = 0
			for {
				fmt.Println(i)
				i++
			}


			//字符串、数组、切片、映射
			desc := "我爱中国"
			for i,ch := range desc {
				fmt.Printf("%d %T %d\n",i,ch,ch)

			}
			//乘法表

			for i := 1; i <= 9; i++ { //1的变量存储到i。i>=9。i++直到+到9.等于i=9
				for j := 1; j <= i; j++ {	//j赋值为1,j>=9 j++直到+到9.等于j=9
					//fmt.Print(i, "*",j, "=",i*j,"\t")
					fmt.Printf("%d * %d =%d\t", j, i, i*j) //%d等于一个占位符。相乘=2个占位符。不足两个占位符的前面补空格
				}
				fmt.Println()			//在每行输出完毕后，使用Println函数打印一个换行符，以换行显示下一行的乘法表。
			}

		   常用的for range循环的语法如下：

		   go
		   for key, value := range collection {
		       // 循环体
		   }
		   这个循环用于遍历集合（例如数组、切片、字符串、映射等）中的元素，每次迭代都会将集合中的键和值分别赋给变量key和value，然后执行循环体。
		   key：表示集合中的键（索引或键值）。
		   value：表示集合中对应键的值。
			集合就是collection
		   循环体可以使用key和value来访问集合中的元素，进行相应的操作。

		   在for range循环中，key和value是集合中的键和值。具体来说：

		   如果集合是数组或切片，key表示元素的索引，value表示元素的值。
		   如果集合是字符串，key表示字符的索引，value表示字符的Unicode码。
		   如果集合是映射（map），key表示键，value表示对应键的值。
		   使用-作为变量名是为了忽略某个变量。在for range循环中，如果你只关心集合中的一个变量（例如只关心值而不关心索引），可以使用_或-来忽略其他变量。

		   例如，如果只关心集合中的值而不关心索引，可以使用以下方式：

		   go
		   for _, value := range collection {
		       // 循环体
		   }
		   在这种情况下，_或-表示忽略集合中的键（索引或键值），只关心值。

	*/
	}
